# .github/workflows/deploy.yml
name: Build and Deploy on Server (ARI)

on:
  push:
    branches: [ master ] # El pipeline se activa al hacer push a la rama master

jobs:
  # Eliminamos el job 'build-and-push' completamente.

  deploy:
    name: Build & Deploy Blue/Green on VPS
    runs-on: ubuntu-latest
    steps:
      - name: Deploy Script via SSH (Build on Server)
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          # Ejecutamos toda la lógica de Git, Docker y Nginx directamente en el VPS.
          script: |
            # 1. Variables y Rutas (usando 'tr -d \r' por si acaso)
            APP_DIR="/home/deployer/ari" 
            REPO_LOWER=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]' | tr -d '\r')
            
            # 2. Preparación del Código: Clonar o Pull
            if [ -d "$APP_DIR/app_source" ]; then
                echo "Haciendo git pull en la fuente existente..."
                cd $APP_DIR/app_source
                git pull origin master
            else
                echo "Clonando el repositorio por primera vez..."
                # Nota: Necesitarás que la llave SSH_PRIVATE_KEY esté también configurada 
                # en el servidor para acceder a repositorios privados si lo necesitas.
                mkdir -p $APP_DIR/app_source
                git clone https://github.com/${{ github.repository }} $APP_DIR/app_source
                cd $APP_DIR/app_source
            fi
            
            # 3. Determinar el slot inactivo
            CURRENT_PRODUCTION=$(cat $APP_DIR/.env 2>/dev/null | grep CURRENT_PRODUCTION | cut -d'=' -f2 | tr -d '\r')
            if [ -z "$CURRENT_PRODUCTION" ] || [ "$CURRENT_PRODUCTION" == "ari-blue" ]; then
                INACTIVE_SLOT="ari-green"
                INACTIVE_PORT="5001"
                INACTIVE_CONF="$APP_DIR/nginx/green.conf"
            else
                INACTIVE_SLOT="ari-blue"
                INACTIVE_PORT="5000"
                INACTIVE_CONF="$APP_DIR/nginx/blue.conf"
            fi
            
            echo "--- Despliegue Build on Server ---"
            echo "Slot inactivo/destino: $INACTIVE_SLOT"
            
            # 4. Construir la imagen Docker en el VPS
            echo "Construyendo nueva imagen localmente..."
            # Usamos el nombre del slot inactivo como tag local
            docker build -t local-build:$INACTIVE_SLOT .
            
            # 5. Detener y Limpiar el Contenedor Antiguo
            echo "Deteniendo y eliminando contenedor antiguo $INACTIVE_SLOT"
            docker stop $INACTIVE_SLOT 2>/dev/null || true 
            docker rm $INACTIVE_SLOT 2>/dev/null || true

            # 6. Iniciar nuevo contenedor
            echo "Iniciando nuevo contenedor $INACTIVE_SLOT en puerto $INACTIVE_PORT"
            docker run -d \
                --name $INACTIVE_SLOT \
                -p $INACTIVE_PORT:4000 \ 
                -e APP_COLOR=$INACTIVE_SLOT \ 
                --restart unless-stopped \
                local-build:$INACTIVE_SLOT
            
            echo "Esperando 10 segundos para que el contenedor inicie..."
            sleep 10
            
            # 7. Swap de Nginx
            echo "Realizando swap de Nginx a $INACTIVE_SLOT"
            sudo ln -snf "$INACTIVE_CONF" "/etc/nginx/current_upstream.conf" 
            sudo systemctl reload nginx 
            
            # 8. Actualizar estado
            echo "Actualizando estado. Nuevo slot de producción: $INACTIVE_SLOT"
            echo "CURRENT_PRODUCTION=$INACTIVE_SLOT" > "$APP_DIR/.env"
            
            echo "¡Despliegue finalizado!"